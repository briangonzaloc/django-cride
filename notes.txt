---------------------
The twelve-factor App
---------------------
SaaS- Sofwtare as a service
Principios:
- Formas declarativas de configuración: minimizar tiempo y costo para empezar a desarrollar
- Un contrato claro con el OS: portabilidad
- Listas para lanzar :
- Minimizar la difrencia entre entornos de desarrollo: agilidad
- Fácil de escalar: servir a mas usuarios, no cambiar la arquitectura o practicas de desarrollo

1- Codebase:  Se refiere a que nuestra app siempre debe estar trackeada por un sistema de control de versiones como Git, Mercurial, etc. Una sola fuente de verdad.

2- Dependencias: Una 12 factor app nunca debe depender de la existencia implícita de nuestro OS, siempre se declaran explícitamente qué dependencias usa el proyecto y se encarga de que estas no se filtren. Dependency Isolation (UTilizando virtual env, docker, etc).

3- Configuración: Acá nos referimos a algo que va a cambiar durante entornos.

4- Backing services: Estos pueden ser conectados y desconectados a voluntad. Es cualquier servicio que nuestra aplicación puede consumir a través de la red como Base de Datos, Mensajería y Cola, Envío de Emails o Caché.

5- Build, release, run: Separa estrictamente las etapas de construcción y las de ejecución. Build es convertir nuestro código fuente en un paquete.Release es la etapa donde agregamos a nuestro paquete cosas de configuración como variables de entorno y Run donde corremos la aplicación en el entorno correspondiente. Las etapas no se pueden mezclar.

6- Procesos: En el caso más complejo tenemos muchos procesos corriendo como Celery y Redis, en esta parte los procesos son stateless y no comparten nada. Cualquier dato que necesite persistir en memoria o en disco duro tiene que almacenarse en un backing services,

7- Port binding
8- Concurrency
9- Disposability

10- Dev/prod parity: Reducir la diferencia entre entornos para reducir tiempo entre deploys y las personas involucradas sean las mismas que puedan hacer el deploy

11- Logs

12- Admin processes: Tratar los procesos administrativos como una cosa diferente, no deben estar con la app.

-------------------------------
Arquitectura de una aplicacion
-------------------------------
https://github.com/kamranahmedse/developer-roadmap
Un Backend developer es un diseñador, su trabajo consiste un 90% en leer, diseñar, analizar y planear. Un 10% en programar. Nuestro trabajo más importante es el diseño del sistema y las decisiones tomadas son más costosas y más difíciles de cambiar.

El Backend consiste en:
    Servidor
    Aplicación
    Base de Datos

Arquitecturas 
-Monotlítica: Todo está manejado por el mismo servidor
-Distribuida: Los compnentes estan descoplados y son consumidos en la red
-Hibrido: Cómo se muetra el sitio web. Mezcla de de Frontend api y backend
-Orientados a servicios(SOA): El servicio:
	Es auto-contenido: no dependen de los demas, independiente del lenguaje de programacion
	Es una caja negra para los consumidores
	Representa una actividad de negocio con un fin específico


-Web services: la manera en que se implementan las arquitecturas orientadas a servicios.
Siguien estándares populares
	SOAP (xml)
	RESTful HTTP es stateless, protocolo HTTP.
	GraphQL Funciona más como un Query Language para las API, un lenguaje de consultas.

-------------------------
Codebase: Setting modular
-------------------------
Docker y Docker Compose

Contenedores/Servicios 4)
Django(:8000) - PostgreSQL(:5432) - Redis(:6379) como servidor de cache - Celery(:5555)
Celery esta cmpuesto de  3 servicios. FLower va a correr en el puerto 5555

Code 
https://github.com/pablotrinidad/cride-platzi/tree/1/Codebase

$ git clone -b 1/Codebase --single-branch https://github.com/pablotrinidad/cride-platzi.git
$ docker-compose -f local.yml build


Estructura directorio
config
	-settings
		-base.py
		-local.py
		-production.py
		-test.py
	-urls.py
	wsgi.py

setting/settings/base.py
libreria environ

----------------
Codebase: Docker
----------------
docker-compose -f local.yml build

Docker-composer crea imagenes:
- cride_local_celerybeat
- cride_local_celeryworker
- cride_local_django
- cride_local_flower
- cride_production_postgres

Ademas descargó las imagenes:
- python
- postgres

Crear la red, los volumenes y levanter los servicios:
$docker-compose -f local.yml up

-Para saber los contenedores que estan corriendo:
docker-compose -f local.yml ps

Corriendo en localhost:8000

-Para matar la aplicacion y detener los servicios:
$ docker-compose -f local.yml down

-Para evitar hacer '-f local.yml' se puede crear una variable de entorno en nuestra sesion de terminal
$ export COMPOSE_FILE=local.yml
Entonces despues se puede hacer
docker-compose build
docker-compose up
docker-compose ps
docker-compose down
Y asi docker va a saber que se hacer referencia al archivo local.yml

comandos administrativos
Luego tengo que interactuar con el manage.py para crear usuarios etc
-- rm para que docker cuando se termine de ejecutarse el comando, mate el contenedor
django es el servicio

$ export COMPOSE_FILE=local.yml
$ docker-compose run --rm django COMMAND
$ docker-compose run --rm django python manage.py createsuperuser


Luego si ejecutamos 
$ docker-compose ps
vemos que no nos creo otro contenedor porque parametro --rm 


Habilitar debugger: Corremos todo, matamos django y solo volvemos a correr django en otra sesion para interactuar (-service-port para exponer los puertos)
$ docker-compse up
$ docker-compose ps
$ docker rm -f <ID_DJANGO>
$ docker-compose run --rm --service-ports django

Recordar comandos utiles de docker

$docker container
$docker images
$docker volume
$docker network

Y para estos tenemos ls, rm, prune (quitar todo lo que no se usa), -a (para mostar todo), -q (Para solo usar los ids) y --head


-------------------
Setups alternativos
-------------------

cookiecutter django: Better project template

De la clase 7 vayan a la 9 y la clase 8 la vean despues de la clase 13  "Creando el modelo de perfil de usuario" y 
luego continuen con la 14 normal

-------------------
Herencia de modelos
-------------------

Las clases heredan de django.db.models

Para que no se refleje en la base de datos usa class Meta: abstract=True

------------
Proxy models - Herencia
------------
Sin crear una nueva tabla en la BD
Las abstracta exponen molde atributo
proxy extienden de una tabla ya existente y agregan funciones de la clase

class Meta: proxy=True

---------------
App de usuarios
---------------
Creamos la app de usuario de forma manual. 
- Crear Folder users y dentro:
1- __init__.py para que sea un modulo de python
2- apps.py = class UsersAppConfig con name y verbose_name
3- Instalarla en config/settings/base.py  -> LOCAL_APPS
4- Folder: migrations que es un modulo. Por lo tanto debe tener el archivo __init__.py
5- models.py

Extension OCTOTREE para github

Django por default se loguea con username.
Se cambia a que se loguee por email, con la variable USERNAME_FIELD
Alternativas:
- extender de User Model con un OneToOneField
- Pero se recomiendo heredar de un propio usuario que hereda de AbstractUser

-------------------------------------------
Organizando modelos en un paquete de Django
-------------------------------------------
Validators para validar campos
En settings base.py hay que setear el Custom user en la variable AUTH_USER_MODEL

ValueError: Dependency on app with no migrations: users
Solucion
Detener el servicio
docker-compose run --rm --service-ports django python manage.py makemigrations
Iniciar de nuevo
$ docker-compose run --rm --service-ports django


django.db.migrations.exceptions.InconsistentMigrationHistory Migration admin.0001_initial is applied before its dependency users.0001_initial on database 'default'.
Incosistencia porque ya sea habia creado el model usuario (no el custom)
Solución
docker-compose ps
docker-compose down
docker volume ls
y borramos el cride-platzi_local_postgres_data
docker volume rm cride-platzi_local_postgres_data

Esto es para limpiar la bd

Luego corremos de nuevo. Levantamos el stack
docker-compose up

Y otra vez matamos el de django
docker-compose ps
docker rm -f cride-platzi_django_1
docker-compose run --rm --service-ports django

--------------------------------------
Creando el modelo de perfil de usuario
--------------------------------------
Primero cambiamos la version de django en requirements porque desde github nos avisaba de la vulnerabilidad.
Luego docker-compose build para construir nuevamente

--------------------------------
Aplicacion y modelo de circuitos
--------------------------------

Pasos 
docker images ls
export COMPOSE_FILE=local.yml
docker-compose up

export COMPOSE_FILE=local.yml
docker-compose ps
docker rm -f cride_django_
docker-compose run --rm --service-port django

export COMPOSE_FILE=local.yml

Crea el model Circle

-------------------------------
Migraciones y admin de círculos
-------------------------------
En las settings local.py tenemos instalada la app django_extensions
con la cual podemos ejecutar el comando shell_plus
docker-compose run --rm django python manage.py shell_plus
importa nuestros modelos y otros necesearios para no tener que hacerlos nosotros


import csv

defimport_csv(csv_filename):
    with open(csv_filename, mode='r') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            circle = Circle(**row)
            circle.save()
            print(circle.name)


filename = https://gist.github.com/pablotrinidad/93ee462e0ee761bd505f0a2fed3d1c8c
import_csv(filename)